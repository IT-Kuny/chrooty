#!/usr/bin/env bash
# chrooty: rescue and chroot utility
# – robust error handling, modular structure, dynamic volume detection,
#   EFI support, interactive & non-interactive modes, verbose logging,
#   self-provisioned log rotation, and extensible plugin architecture.

set -eEuo pipefail
IFS=$'\n\t'

APP="chrooty"
LOGFILE="/var/log/${APP}.log"
CHROOT_DIR="/mnt/${APP}"
HOOK_DIR="hooks"
PRE_HOOK_DIR="${HOOK_DIR}/pre_chroot.d"
POST_HOOK_DIR="${HOOK_DIR}/post_chroot.d"
TMP_MNT=""
NONINTERACTIVE=0
SYSTEM_ONLY=0
UEFI_ONLY=0
VERBOSE=0
BTRFS_SUBVOL=""

########################
# 0) Logging & Rotation#
########################

log() {
  local ts; ts=$(date '+%Y-%m-%d %H:%M:%S')
  echo "${ts} ${APP}: $1" >> "${LOGFILE}"
}

verbose_log() {
  log "$1"
  if (( VERBOSE )); then
    echo "${APP}: $1"
  fi
}

install_logrotate() {
  local cfg="/etc/logrotate.d/${APP}"
  if [[ ! -f "$cfg" ]]; then
    cat <<'EOF' > "$cfg"
/var/log/chrooty.log {
    weekly
    rotate 4
    compress
    missingok
    notifempty
    create 0640 root adm
}
EOF
    chmod 644 "$cfg"
    log "Installed logrotate config at $cfg"
  else
    log "Logrotate config already present at $cfg"
  fi
}

init_log() {
  touch "${LOGFILE}"
  chmod 640 "${LOGFILE}" || true
  log "Log initialized"
  install_logrotate
}

###########
# Cleanup #
###########
cleanup() {
  log "Beginning cleanup of mount points"

  # Helper: unmount a given target if mounted
  _umount() {
    local target="$1"
    if mountpoint -q "$target"; then
      log "Unmounting $target"
      if ! umount "$target"; then
        log "  Standard unmount failed for $target, trying lazy unmount"
        umount -l "$target" || log "  Lazy unmount also failed for $target"
      fi
    fi
  }

  # 1) Unmount everything under CHROOT_DIR in reverse-depth order
  if [[ -d "$CHROOT_DIR" ]]; then
    # Collect all mount points under $CHROOT_DIR
    mapfile -t mounts < <(
      mount | awk -v mnt="$CHROOT_DIR" '
        $3 ~ "^"mnt {
          # print depth, mountpoint
          depth = gsub("/", "", $3)
          print depth " " $3
        }
      ' | sort -rn
    )
    # Iterate and unmount
    for entry in "${mounts[@]}"; do
      target="${entry#* }"
      _umount -l "$target"
      rmdir "$target" 2>/dev/null || true
    done
  fi

  # 2) Unmount auxiliary binds (bin, usr/bin, lib, lib64, etc.)
  for dir in bin usr/bin lib lib64 usr/lib usr/lib64 run; do
    _umount -l "${CHROOT_DIR}/${dir}"
    rmdir "${CHROOT_DIR}/${dir}" 2>/dev/null || true
  done

  # 3) Finally unmount and remove the root mount
  _umount -l "$CHROOT_DIR"
  rmdir "$CHROOT_DIR" 2>/dev/null || true

  log "Cleanup complete"
}

trap 'cleanup; log "Error on line $LINENO"; exit 1' ERR INT TERM
# 1) On any error, log it (but don’t clean up here)
trap 'log "Error on line $LINENO. Exiting."' ERR TERM
# 2) Always run cleanup() on exit (success or failure)
trap 'cleanup' EXIT INT TERM

###################
# Argument parser #
###################
parse_args() {
  local opts
  opts=$(getopt -o nv --long no-prompt,verbose,system,uefi -n "${APP}" -- "$@") || exit 1
  eval set -- "$opts"
  while true; do
    case "$1" in
      -n|--no-prompt) NONINTERACTIVE=1; shift ;;
      -v|--verbose)   VERBOSE=1;        shift ;;
      --system)       SYSTEM_ONLY=1;    shift ;;
      --uefi)         UEFI_ONLY=1;      shift ;;
      --)             shift; break ;;
      *) echo "${APP}: Invalid option: $1" >&2; exit 1 ;;
    esac
  done

  # Validate combinations
  if (( SYSTEM_ONLY && UEFI_ONLY )); then
    echo "${APP}: Cannot specify both --system and --uefi" >&2
    exit 1
  fi
  if (( NONINTERACTIVE && SYSTEM_ONLY==0 && UEFI_ONLY==0 )); then
    echo "${APP}: --no-prompt requires either --system or --uefi" >&2
    exit 1
  fi
  (( VERBOSE )) && verbose_log "Flags - no-prompt=${NONINTERACTIVE}, system=${SYSTEM_ONLY}, uefi=${UEFI_ONLY}"
  if (( NONINTERACTIVE==0 )); then
    verbose_log "Interactive mode enabled"
  fi
}

########################################
# Plugin Infrastructure (pre/post hooks)
########################################
ensure_hook_dirs() {
  mkdir -p "${PRE_HOOK_DIR}" "${POST_HOOK_DIR}"
  log "Ensured hook directories exist"
}

run_pre_chroot_hooks() {
  verbose_log "Executing pre-chroot hooks"
  for hook in "${PRE_HOOK_DIR}"/*.sh; do
    [[ -x "$hook" ]] || continue
    verbose_log "› Running hook: $(basename "$hook")"
    source "$hook"
  done
}

run_post_chroot_hooks() {
  verbose_log "Executing post-chroot hooks"
  for hook in "${POST_HOOK_DIR}"/*.sh; do
    [[ -x "$hook" ]] || continue
    verbose_log "› Running hook: $(basename "$hook")"
    source "$hook"
  done
}

#################################
#  Partition & Volume Detection #
#################################
detect_partitions() {
  verbose_log "Detecting partitions and volumes"

  # 1) Retrieve raw JSON from lsblk
  local raw_lsblk
  raw_lsblk=$(lsblk --json -o NAME,TYPE,PTTYPE,PARTLABEL,FSTYPE) || {
    log "Failed to run lsblk"
    exit 1
  }

  # 2) Flatten blockdevices + nested children into one array
  #    We drop the original top-level wrapper to get .[] items directly.
  local lsblk_json
  lsblk_json=$(
    jq -c '
      [ .blockdevices[] 
        | { name, type, pttype, partlabel, fstype } ] +
      [ .blockdevices[] 
        | .children[]? 
        | { name, type, pttype, partlabel, fstype } ]
    ' <<<"$raw_lsblk"
  ) || { log "Failed to flatten lsblk JSON"; exit 1; }

  # 3) (Verbose) Report top-level disks and their partition tables
  if (( VERBOSE )); then
    verbose_log "Disks and partition tables:"
    jq -r '
      .blockdevices[] 
      | select(.type=="disk") 
      | "  /dev/\(.name): table=\(.pttype // \"unknown\")"
    ' <<<"$raw_lsblk" | while read -r line; do
      log "$line"
      echo "$line"
    done
  fi

  # 4) LVM detection
  if jq -e '.[] | select(.fstype=="LVM2_member")' <<<"$lsblk_json" &>/dev/null; then
    verbose_log "LVM PVs detected—scanning for LV"
    pvscan --cache &>/dev/null
    vgscan --mknodes &>/dev/null
    ROOT_PART=$(
      lvscan --verbose \
        | awk '/^  ACTIVE/ { gsub(/"/,"",$2); print $2; exit }'
    )
    [[ -n "$ROOT_PART" ]] || { log "No active LVM LV found"; exit 1; }

  # 5) ZFS detection
  elif jq -e '.[] | select(.fstype=="zfs_member")' <<<"$lsblk_json" &>/dev/null; then
    verbose_log "ZFS detected—selecting first zvol"
    local zvol
    zvol=$(zfs list -H -o name -t volume | head -n1)
    [[ -n "$zvol" ]] || { log "No ZFS volume found"; exit 1; }
    ROOT_PART="/dev/zvol/${zvol}"

  # 6) Btrfs detection
  else
    local bdev
    bdev=$(
      jq -r '
        .[] 
        | select(.type=="part" and .fstype=="btrfs") 
        | "/dev/"+.name
      ' <<<"$lsblk_json" | head -n1
    )
    if [[ -n "$bdev" ]]; then
      verbose_log "Btrfs detected on $bdev—inspecting subvolumes"
      TMP_MNT=$(mktemp -d /dev/shm/chrooty.XXXX)
      mount "$bdev" "$TMP_MNT"
      mapfile -t subvols < <(
        btrfs subvolume list -o "$TMP_MNT" | awk '{print $9}'
      )
      umount "$TMP_MNT" && rmdir "$TMP_MNT"
      if printf '%s\n' "${subvols[@]}" | grep -qx "@"; then
        BTRFS_SUBVOL="@"
      else
        BTRFS_SUBVOL="5"
      fi
      ROOT_PART="$bdev"
      verbose_log "Selected BTRFS_SUBVOL=$BTRFS_SUBVOL"
    else
      # 7) Native filesystem fallback
      verbose_log "Falling back to native FS (ext4, xfs, exfat)"
      ROOT_PART=$(
        jq -r '
          .[] 
          | select(
              .type=="part" and
              (.fstype=="ext4" or .fstype=="xfs" or .fstype=="exfat")
            )
          | "/dev/"+.name
        ' <<<"$lsblk_json" | head -n1
      )
      [[ -n "$ROOT_PART" ]] || { log "No suitable native filesystem found"; exit 1; }
    fi
  fi

  # 8) EFI partition detection (always from flattened list)
  EFI_PART=$(
    jq -r '
      .[] 
      | select(
          .type=="part" and
          (.fstype=="vfat" or .fstype=="fat32") and
          (.partlabel | test("EFI"; "i"))
        )
      | "/dev/"+.name
    ' <<<"$lsblk_json" | head -n1
  )

  verbose_log "Using ROOT_PART=$ROOT_PART"
  if [[ -n "$EFI_PART" ]]; then
    verbose_log "Detected EFI_PART=$EFI_PART"
  elif (( UEFI_ONLY )); then
    log "EFI-only mode but no EFI partition found"
    exit 1
  fi

  # 9) Final sanity check via blkid
  blkid "$ROOT_PART" &>/dev/null \
    || { log "blkid probe failed on $ROOT_PART"; exit 1; }
  [[ -z "$EFI_PART" ]] \
    || blkid "$EFI_PART" &>/dev/null \
       || { log "blkid probe failed on $EFI_PART"; exit 1; }

  export ROOT_PART EFI_PART BTRFS_SUBVOL
}

choose_partitions() {
  echo
  echo "Detected partitions:"
  lsblk -plno NAME,FSTYPE,SIZE,PARTLABEL | column -t

  # Build arrays of candidates
  mapfile -t os_parts < <(
    lsblk -plno NAME,FSTYPE |
      awk '$2 ~ /^(ext4|xfs|exfat|btrfs|LVM2_member|zfs_member)$/ { print $1 " (" $2 ")" }'
  )
  mapfile -t efi_parts < <(
    lsblk -plno NAME,FSTYPE,PARTLABEL |
      awk '$2 ~ /^(vfat|fat32)$/ && tolower($3) ~ /efi/ { print $1 " (" $2 ")" }'
  )

  # Choose ROOT_PART
  if (( ${#os_parts[@]} == 1 )); then
    echo
    echo "Single OS partition detected: ${os_parts[0]}"
    read -rn1 -p "Press any key to confirm... " 
    echo
    ROOT_PART="${os_parts[0]%% *}"
  else
    echo
    echo "Select the partition to use for the OS/root:"
    select entry in "${os_parts[@]}"; do
      if [[ -n "$entry" ]]; then
        ROOT_PART="${entry%% *}"
        break
      fi
    done
  fi

  # Choose EFI_PART (if any)
  if (( ${#efi_parts[@]} == 0 )); then
    echo
    echo "No EFI partition detected; continuing in BIOS mode."
    EFI_PART=""
  elif (( ${#efi_parts[@]} == 1 )); then
    echo
    echo "Single EFI partition detected: ${efi_parts[0]}"
    read -rn1 -p "Press any key to confirm... "
    echo
    EFI_PART="${efi_parts[0]%% *}"
  else
    echo
    echo "Select the partition to use for EFI:"
    select entry in "${efi_parts[@]}"; do
      if [[ -n "$entry" ]]; then
        EFI_PART="${entry%% *}"
        break
      fi
    done
  fi

  verbose_log "User selected ROOT_PART=${ROOT_PART}, EFI_PART=${EFI_PART:-<none>}"
  log "User selected ROOT_PART=${ROOT_PART}, EFI_PART=${EFI_PART:-<none>}"
}

mount_chroot() {
  verbose_log "Mounting chroot at ${CHROOT_DIR}"
  mkdir -p "${CHROOT_DIR}"
  run_pre_chroot_hooks

  # 1) Determine filesystem type for the root device
  local root_fstype
  root_fstype=$(blkid -s TYPE -o value "${ROOT_PART}")

if [[ -n "$BTRFS_SUBVOL" ]]; then
  # Btrfs path: numeric → subvolid, otherwise by name
  if [[ "$BTRFS_SUBVOL" =~ ^[0-9]+$ ]]; then
    mount -t btrfs -o subvolid="${BTRFS_SUBVOL}" "${ROOT_PART}" "${CHROOT_DIR}"
  else
    mount -t btrfs -o subvol="${BTRFS_SUBVOL}" "${ROOT_PART}" "${CHROOT_DIR}"
  fi

elif [[ -n "$root_fstype" ]]; then
  # Non-Btrfs path unchanged
  mount -t "$root_fstype" "${ROOT_PART}" "${CHROOT_DIR}"

else
  # For other filesystems, include -t for reliability
  if [[ -n "${root_fstype}" ]]; then
    mount -t "${root_fstype}" "${ROOT_PART}" "${CHROOT_DIR}"
  else
    # Fallback to auto-detect
    mount "${ROOT_PART}" "${CHROOT_DIR}"
  fi
fi

  # 2) Bind-mount system pseudo-filesystems
  for dir in dev dev/pts proc sys run; do
    mkdir -p "${CHROOT_DIR}/${dir}"
    mount --bind "/${dir}" "${CHROOT_DIR}/${dir}"
  done

  # 3) Populate /etc/mtab in the chroot (optional but traditional)
  mkdir -p "${CHROOT_DIR}/etc"
  cp /proc/mounts "${CHROOT_DIR}/etc/mtab"

  # 4) Mount EFI if present
  if [[ -n "${EFI_PART}" ]]; then
    mkdir -p "${CHROOT_DIR}/boot/efi"
    mount -t vfat "${EFI_PART}" "${CHROOT_DIR}/boot/efi"
  fi

  log "Mount complete"
}

unmount_chroot() {
  cleanup             # core unmount logic
  run_post_chroot_hooks
  log "Unmount complete"
}

###################
# Enter the Chroot#
###################
enter_chroot() {
  log "Locating shell inside chroot"
  local candidates=( /bin/bash /usr/bin/bash /bin/sh /usr/bin/sh )
  local shell_path=""

  # 1) Try target-native shells
  for sh in "${candidates[@]}"; do
    if [[ -x "${CHROOT_DIR}${sh}" ]]; then
      shell_path="$sh"
      break
    fi
  done

  # 2) Fallback: bind host bins & libs if no shell
  if [[ -z "$shell_path" ]]; then
    log "No shell in chroot; binding host binaries and libraries"
    for d in bin usr/bin; do
      mkdir -p "${CHROOT_DIR}/${d}"
      mount --bind "/${d}" "${CHROOT_DIR}/${d}"
    done
    for ld in lib lib64 usr/lib usr/lib64; do
      [[ -d "/${ld}" ]] || continue
      mkdir -p "${CHROOT_DIR}/${ld}"
      mount --bind "/${ld}" "${CHROOT_DIR}/${ld}"
    done
    for sh in "${candidates[@]}"; do
      [[ -x "${CHROOT_DIR}${sh}" ]] && shell_path="$sh" && break
    done
    [[ -n "$shell_path" ]] || {
      echo "chrooty: ERROR: No shell available even after binding host libs" >&2
      exit 1
    }
  fi

  # 3) Ensure DNS resolution
  if [[ -L /etc/resolv.conf ]]; then
    # Preserve symlink type
    local target; target=$(readlink /etc/resolv.conf)
    cp -L "/etc/${target}" "${CHROOT_DIR}/etc/$(basename "$target")"
    ln -sr "$(basename "$target")" "${CHROOT_DIR}/etc/resolv.conf"
  else
    cp -L /etc/resolv.conf "${CHROOT_DIR}/etc/resolv.conf"
  fi

  # 4) Enter the chroot
  log "Entering chroot with shell ${shell_path}"
  exec chroot "${CHROOT_DIR}" "${shell_path}"
}

########
# Main #
########
main() {
  init_log
  ensure_hook_dirs
  parse_args "$@"

  if (( NONINTERACTIVE==0 )); then
    PS3="Select action: "
    options=("Rescue System" "Rescue UEFI" "Full Rescue" "Quit")
    select opt in "${options[@]}"; do
      case $opt in
        "Rescue System") SYSTEM_ONLY=1; break ;;
        "Rescue UEFI")   UEFI_ONLY=1;   break ;;
        "Full Rescue")   break ;;
        "Quit")          exit 0       ;;
        *) echo "Invalid selection";;
      esac
    done
  fi

  detect_partitions
  choose_partitions
  mount_chroot
  enter_chroot
  unmount_chroot
}

main "$@"
