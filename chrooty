#!/usr/bin/env bash
# chrooty: rescue and chroot utility
# – robust error handling, modular structure, dynamic volume detection,
#   EFI support, interactive & non-interactive modes, verbose logging,
#   self-provisioned log rotation, and extensible plugin architecture.

set -eEuo pipefail
IFS=$'\n\t'

APP="chrooty"
LOGFILE="/var/log/${APP}.log"
CHROOT_DIR="/mnt/${APP}"
HOOK_DIR="hooks"
PRE_HOOK_DIR="${HOOK_DIR}/pre_chroot.d"
POST_HOOK_DIR="${HOOK_DIR}/post_chroot.d"
TMP_MNT=""
NONINTERACTIVE=0
SYSTEM_ONLY=0
UEFI_ONLY=0
VERBOSE=0
BTRFS_SUBVOL=""

########################
# 0) Logging & Rotation#
########################

log() {
  local ts; ts=$(date '+%Y-%m-%d %H:%M:%S')
  echo "${ts} ${APP}: $1" >> "${LOGFILE}"
}

verbose_log() {
  log "$1"
  if (( VERBOSE )); then
    echo "${APP}: $1"
  fi
}

install_logrotate() {
  local cfg="/etc/logrotate.d/${APP}"
  if [[ ! -f "$cfg" ]]; then
    cat <<'EOF' > "$cfg"
/var/log/chrooty.log {
    weekly
    rotate 4
    compress
    missingok
    notifempty
    create 0640 root adm
}
EOF
    chmod 644 "$cfg"
    log "Installed logrotate config at $cfg"
  else
    log "Logrotate config already present at $cfg"
  fi
}

init_log() {
  touch "${LOGFILE}"
  chmod 640 "${LOGFILE}" || true
  log "Log initialized"
  install_logrotate
}

###########
# Cleanup #
###########
cleanup() {
  log "Beginning cleanup of mount points"

  # Helper: unmount a given target if mounted
  _umount() {
    local target="$1"
    if mountpoint -q "$target"; then
      log "Unmounting $target"
      if ! umount "$target"; then
        log "  Standard unmount failed for $target, trying lazy unmount"
        umount -l "$target" || log "  Lazy unmount also failed for $target"
      fi
    fi
  }

  # 1) Unmount everything under CHROOT_DIR in reverse-depth order
  if [[ -d "$CHROOT_DIR" ]]; then
    # Collect all mount points under $CHROOT_DIR
    mapfile -t mounts < <(
      mount | awk -v mnt="$CHROOT_DIR" '
        $3 ~ "^"mnt {
          # print depth, mountpoint
          depth = gsub("/", "", $3)
          print depth " " $3
        }
      ' | sort -rn
    )
    # Iterate and unmount
    for entry in "${mounts[@]}"; do
      target="${entry#* }"
      _umount "$target"
      rmdir "$target" 2>/dev/null || true
    done
  fi

  # 2) Unmount auxiliary binds (bin, usr/bin, lib, lib64, etc.)
  for dir in bin usr/bin lib lib64 usr/lib usr/lib64 run; do
    _umount "${CHROOT_DIR}/${dir}"
    rmdir "${CHROOT_DIR}/${dir}" 2>/dev/null || true
  done

  # 3) Finally unmount and remove the root mount
  _umount "$CHROOT_DIR"
  rmdir "$CHROOT_DIR" 2>/dev/null || true

  log "Cleanup complete"
}

trap 'cleanup; log "Error on line $LINENO"; exit 1' ERR INT TERM
# 1) On any error, log it (but don’t clean up here)
trap 'log "Error on line $LINENO. Exiting."' ERR TERM
# 2) Always run cleanup() on exit (success or failure)
trap 'cleanup' EXIT INT TERM

###################
# Argument parser #
###################
parse_args() {
  local opts
  opts=$(getopt -o nv --long no-prompt,verbose,system,uefi -n "${APP}" -- "$@") || exit 1
  eval set -- "$opts"
  while true; do
    case "$1" in
      -n|--no-prompt) NONINTERACTIVE=1; shift ;;
      -v|--verbose)   VERBOSE=1;        shift ;;
      --system)       SYSTEM_ONLY=1;    shift ;;
      --uefi)         UEFI_ONLY=1;      shift ;;
      --)             shift; break ;;
      *) echo "${APP}: Invalid option: $1" >&2; exit 1 ;;
    esac
  done

  # Validate combinations
  if (( SYSTEM_ONLY && UEFI_ONLY )); then
    echo "${APP}: Cannot specify both --system and --uefi" >&2
    exit 1
  fi
  if (( NONINTERACTIVE && SYSTEM_ONLY==0 && UEFI_ONLY==0 )); then
    echo "${APP}: --no-prompt requires either --system or --uefi" >&2
    exit 1
  fi
  (( VERBOSE )) && verbose_log "Flags - no-prompt=${NONINTERACTIVE}, system=${SYSTEM_ONLY}, uefi=${UEFI_ONLY}"
  if (( NONINTERACTIVE==0 )); then
    verbose_log "Interactive mode enabled"
  fi
}

########################################
# Plugin Infrastructure (pre/post hooks)
########################################
ensure_hook_dirs() {
  mkdir -p "${PRE_HOOK_DIR}" "${POST_HOOK_DIR}"
  log "Ensured hook directories exist"
}

run_pre_chroot_hooks() {
  verbose_log "Executing pre-chroot hooks"
  for hook in "${PRE_HOOK_DIR}"/*.sh; do
    [[ -x "$hook" ]] || continue
    verbose_log "› Running hook: $(basename "$hook")"
    source "$hook"
  done
}

run_post_chroot_hooks() {
  verbose_log "Executing post-chroot hooks"
  for hook in "${POST_HOOK_DIR}"/*.sh; do
    [[ -x "$hook" ]] || continue
    verbose_log "› Running hook: $(basename "$hook")"
    source "$hook"
  done
}

#################################
#  Partition & Volume Detection #
#################################
detect_partitions() {
  verbose_log "Detecting partitions and volumes"

  # 1) Retrieve raw JSON from lsblk
  local raw_lsblk
  raw_lsblk=$(lsblk --json -o NAME,TYPE,PTTYPE,PARTLABEL,FSTYPE) || {
    log "Failed to run lsblk"
    exit 1
  }

  # 2) Flatten blockdevices + nested children into one array
  #    We drop the original top-level wrapper to get .[] items directly.
  local lsblk_json
  lsblk_json=$(
    jq -c '
      [ .blockdevices[] 
        | { name, type, pttype, partlabel, fstype } ] +
      [ .blockdevices[] 
        | .children[]? 
        | { name, type, pttype, partlabel, fstype } ]
    ' <<<"$raw_lsblk"
  ) || { log "Failed to flatten lsblk JSON"; exit 1; }

  # 3) (Verbose) Report top-level disks and their partition tables
  if (( VERBOSE )); then
    verbose_log "Disks and partition tables:"
    jq -r '
      .blockdevices[] 
      | select(.type=="disk") 
      | "  /dev/\(.name): table=\(.pttype // \"unknown\")"
    ' <<<"$raw_lsblk" | while read -r line; do
      log "$line"
      echo "$line"
    done
  fi

  # 4) LVM detection
  if jq -e '.[] | select(.fstype=="LVM2_member")' <<<"$lsblk_json" &>/dev/null; then
    verbose_log "LVM PVs detected—scanning for LV"
    pvscan --cache &>/dev/null
    vgscan --mknodes &>/dev/null
    ROOT_PART=$(
      lvscan --verbose \
        | awk '/^  ACTIVE/ { gsub(/"/,"",$2); print $2; exit }'
    )
    [[ -n "$ROOT_PART" ]] || { log "No active LVM LV found"; exit 1; }

  # 5) ZFS detection
  elif jq -e '.[] | select(.fstype=="zfs_member")' <<<"$lsblk_json" &>/dev/null; then
    verbose_log "ZFS detected—selecting first zvol"
    local zvol
    zvol=$(zfs list -H -o name -t volume | head -n1)
    [[ -n "$zvol" ]] || { log "No ZFS volume found"; exit 1; }
    ROOT_PART="/dev/zvol/${zvol}"

  # 6) Btrfs detection
  else
    local bdev
    bdev=$(
      jq -r '
        .[] 
        | select(.type=="part" and .fstype=="btrfs") 
        | "/dev/"+.name
      ' <<<"$lsblk_json" | head -n1
    )
    if [[ -n "$bdev" ]]; then
      verbose_log "Btrfs detected on $bdev—inspecting subvolumes"
      TMP_MNT=$(mktemp -d /dev/shm/chrooty.XXXX)
      mount "$bdev" "$TMP_MNT"
      mapfile -t subvols < <(
        btrfs subvolume list -o "$TMP_MNT" | awk '{print $9}'
      )
      umount "$TMP_MNT" && rmdir "$TMP_MNT"
      if printf '%s\n' "${subvols[@]}" | grep -qx "@"; then
        BTRFS_SUBVOL="@"
      else
        BTRFS_SUBVOL="5"
      fi
      ROOT_PART="$bdev"
      verbose_log "Selected BTRFS_SUBVOL=$BTRFS_SUBVOL"
    else
      # 7) Native filesystem fallback
      verbose_log "Falling back to native FS (ext4, xfs, exfat)"
      ROOT_PART=$(
        jq -r '
          .[] 
          | select(
              .type=="part" and
              (.fstype=="ext4" or .fstype=="xfs" or .fstype=="exfat")
            )
          | "/dev/"+.name
        ' <<<"$lsblk_json" | head -n1
      )
      [[ -n "$ROOT_PART" ]] || { log "No suitable native filesystem found"; exit 1; }
    fi
  fi

  # 8) EFI partition detection (always from flattened list)
  EFI_PART=$(
    jq -r '
      .[] 
      | select(
          .type=="part" and
          (.fstype=="vfat" or .fstype=="fat32") and
          (.partlabel | test("EFI"; "i"))
        )
      | "/dev/"+.name
    ' <<<"$lsblk_json" | head -n1
  )

  verbose_log "Using ROOT_PART=$ROOT_PART"
  if [[ -n "$EFI_PART" ]]; then
    verbose_log "Detected EFI_PART=$EFI_PART"
  elif (( UEFI_ONLY )); then
    log "EFI-only mode but no EFI partition found"
    exit 1
  fi

  # 9) Final sanity check via blkid
  blkid "$ROOT_PART" &>/dev/null \
    || { log "blkid probe failed on $ROOT_PART"; exit 1; }
  [[ -z "$EFI_PART" ]] \
    || blkid "$EFI_PART" &>/dev/null \
       || { log "blkid probe failed on $EFI_PART"; exit 1; }

  export ROOT_PART EFI_PART BTRFS_SUBVOL
}

choose_partitions() {
  echo
  echo "Loading partitions:"
  lsblk -plno NAME,FSTYPE,SIZE,PARTLABEL | column -t

  # Build arrays of candidates
  mapfile -t os_parts < <(
    lsblk -plno NAME,FSTYPE |
      awk '$2 ~ /^(ext4|xfs|exfat|btrfs|LVM2_member|zfs_member)$/ { print $1 " (" $2 ")" }'
  )
  mapfile -t efi_parts < <(
    lsblk -plno NAME,FSTYPE,PARTLABEL |
      awk '$2 ~ /^(vfat|fat32)$/ && tolower($3) ~ /efi/ { print $1 " (" $2 ")" }'
  )

  # ----- OS selection -----
  echo
  echo "OS (root) partition candidates:"
  for i in "${!os_parts[@]}"; do
    printf "  %d) %s\n" $((i+1)) "${os_parts[i]}"
  done
  local os_prompt="Select OS partition [1]: "
  read -rp "$os_prompt" os_choice
  if [[ -z "$os_choice" ]]; then
    os_choice=1
  fi
  if ! [[ "$os_choice" =~ ^[0-9]+$ ]] || (( os_choice < 1 || os_choice > ${#os_parts[@]} )); then
    echo "Invalid choice; defaulting to 1."
    os_choice=1
  fi
  ROOT_PART="${os_parts[os_choice-1]%% *}"
  echo "-> Using OS partition: $ROOT_PART"

  # ----- EFI selection -----
  if (( ${#efi_parts[@]} == 0 )); then
    echo
    echo "No EFI partition detected; continuing in BIOS mode."
    EFI_PART=""
  else
    echo
    echo "EFI partition candidates:"
    for i in "${!efi_parts[@]}"; do
      printf "  %d) %s\n" $((i+1)) "${efi_parts[i]}"
    done
    local efi_prompt="Select EFI partition [1]: "
    read -rp "$efi_prompt" efi_choice
    if [[ -z "$efi_choice" ]]; then
      efi_choice=1
    fi
    if ! [[ "$efi_choice" =~ ^[0-9]+$ ]] || (( efi_choice < 1 || efi_choice > ${#efi_parts[@]} )); then
      echo "Invalid choice; defaulting to 1."
      efi_choice=1
    fi
    EFI_PART="${efi_parts[efi_choice-1]%% *}"
    echo "-> Using EFI partition: $EFI_PART"
  fi

  verbose_log "User selected ROOT_PART=${ROOT_PART}, EFI_PART=${EFI_PART:-<none>}"
  log "User selected ROOT_PART=${ROOT_PART}, EFI_PART=${EFI_PART:-<none>}"
}

mount_chroot() {
  verbose_log "Mounting root filesystem at ${CHROOT_DIR}"
  mkdir -p "${CHROOT_DIR}"
  run_pre_chroot_hooks

  # 1) Mount the root filesystem
  local root_fstype
  root_fstype=$(blkid -s TYPE -o value "${ROOT_PART}" || echo "")

  if [[ -n "$BTRFS_SUBVOL" ]]; then
    # Btrfs: numeric IDs use subvolid, names use subvol
    if [[ "$BTRFS_SUBVOL" =~ ^[0-9]+$ ]]; then
      mount -t btrfs -o subvolid="${BTRFS_SUBVOL}" "${ROOT_PART}" "${CHROOT_DIR}"
    else
      mount -t btrfs -o subvol="${BTRFS_SUBVOL}" "${ROOT_PART}" "${CHROOT_DIR}"
    fi
  elif [[ -n "$root_fstype" ]]; then
    mount -t "$root_fstype" "${ROOT_PART}" "${CHROOT_DIR}"
  else
    mount "${ROOT_PART}" "${CHROOT_DIR}"
  fi

  # 2) Detect whether the OS filesystem is populated
  local populated=0
  if [[ -d "${CHROOT_DIR}/etc" && -n "$(ls -A "${CHROOT_DIR}/etc")" ]]; then
    populated=1
  fi

  if (( populated )); then
    verbose_log "Filesystem looks populated—proceeding with binds"

    # 3) Bind-mount pseudo-filesystems
    for dir in dev dev/pts proc sys run; do
      mkdir -p "${CHROOT_DIR}/${dir}"
      mount --bind "/${dir}" "${CHROOT_DIR}/${dir}"
    done

    # 4) Bind-mount DNS
    mkdir -p "${CHROOT_DIR}/etc"
    # Ensure the target file exists
    : > "${CHROOT_DIR}/etc/resolv.conf"
    if [[ -e /etc/resolv.conf ]]; then
      mount --bind /etc/resolv.conf "${CHROOT_DIR}/etc/resolv.conf"
    fi

    # 5) Populate /etc/mtab
    cp /proc/mounts "${CHROOT_DIR}/etc/mtab"

    # 6) Mount EFI if present
    if [[ -n "${EFI_PART}" ]]; then
      mkdir -p "${CHROOT_DIR}/boot/efi"
      mount -t vfat "${EFI_PART}" "${CHROOT_DIR}/boot/efi"
    fi

    log "All binds complete"
  else
    verbose_log "Target filesystem appears empty—skipping bind mounts and DNS"
    log "Warning: root partition ${ROOT_PART} has no content; install or populate it first"
  fi
}

unmount_chroot() {
  cleanup             # core unmount logic
  run_post_chroot_hooks
  log "Unmount complete"
}

###################
# Enter the Chroot#
###################
enter_chroot() {
  log "Locating shell inside chroot"
  local candidates=( /bin/bash /usr/bin/bash /bin/sh /usr/bin/sh )
  local shell_path=""

  # 1) Try target-native shells
  for sh in "${candidates[@]}"; do
    if [[ -x "${CHROOT_DIR}${sh}" ]]; then
      shell_path="$sh"
      break
    fi
  done

  # 2) Fallback: bind host bins & libs if no shell
if [[ -z "$shell_path" ]]; then
  log "No shell in chroot; binding host binaries and libraries"
  # Binaries
  for d in bin usr/bin; do
    mkdir -p "${CHROOT_DIR}/${d}"
    mount --bind "/${d}" "${CHROOT_DIR}/${d}"
  done
fi
  # Libraries
for ld in lib lib64 usr/lib usr/lib64; do
    [[ -d "/${ld}" ]] || continue
    mkdir -p "${CHROOT_DIR}/${ld}"
    mount --bind "/${ld}" "${CHROOT_DIR}/${ld}"
  done

  # **sudo’s helper modules**
  if [[ -d /usr/libexec/sudo ]]; then
    mkdir -p "${CHROOT_DIR}/usr/libexec/sudo"
    mount --bind "/usr/libexec/sudo" "${CHROOT_DIR}/usr/libexec/sudo"
fi

  # Only bind-mount host /etc/resolv.conf if the OS image already has /etc
  if [[ -d "${CHROOT_DIR}/etc" && -e /etc/resolv.conf ]]; then
    mount --bind /etc/resolv.conf "${CHROOT_DIR}/etc/resolv.conf"
  fi

  # 4) Enter the chroot
  log "Entering chroot with shell ${shell_path}"
  chroot "${CHROOT_DIR}" "${shell_path}"
}

########
# Main #
########
main() {
  init_log
  ensure_hook_dirs
  parse_args "$@"

  if (( NONINTERACTIVE==0 )); then
    PS3="Select action: "
    options=("Rescue System" "Rescue UEFI" "Full Rescue" "Quit")
    select opt in "${options[@]}"; do
      case $opt in
        "Rescue System") SYSTEM_ONLY=1; break ;;
        "Rescue UEFI")   UEFI_ONLY=1;   break ;;
        "Full Rescue")   break ;;
        "Quit")          exit 0       ;;
        *) echo "Invalid selection";;
      esac
    done
  fi

  detect_partitions
  choose_partitions
  mount_chroot
  enter_chroot
  unmount_chroot
}

main "$@"
